package com.kstudio.ultracoinflip.security;

import com.kstudio.ultracoinflip.KStudio;
import com.kstudio.ultracoinflip.data.CoinFlipGame;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Level;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;

public class ExploitDetector {
   private final KStudio plugin;
   private final File logFile;
   private final BlockingQueue<String> logQueue;
   private final SimpleDateFormat dateFormat;
   private volatile boolean running;
   private Thread writerThread;
   private volatile boolean enabled;
   private volatile boolean consoleLogging;
   private volatile boolean fileLogging;
   private volatile boolean adminNotify;
   private volatile String adminPermission;
   private final Map<String, Long> lastLogTime = new ConcurrentHashMap<>();
   private final Map<UUID, ExploitDetector.PlayerExploitData> playerExploitData = new ConcurrentHashMap<>();
   private static final long LOG_COOLDOWN_MS = 5000L;
   private static final int SUSPICIOUS_THRESHOLD = 3;
   private static final long SUSPICIOUS_WINDOW_MS = 30000L;

   public ExploitDetector(KStudio plugin) {
      this.plugin = plugin;
      this.logFile = new File(plugin.getDataFolder(), "exploit-detection.log");
      this.logQueue = new LinkedBlockingQueue<>();
      this.dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
      this.running = true;
      this.reloadConfig();
      if (this.fileLogging) {
         try {
            if (!this.logFile.exists()) {
               this.logFile.getParentFile().mkdirs();
               this.logFile.createNewFile();
            }
         } catch (IOException var3) {
            plugin.getLogger().warning("Failed to create exploit detection log file: " + var3.getMessage());
         }
      }

      this.startWriterThread();
      plugin.getLogger().info("[ExploitDetector] Security system initialized" + (this.enabled ? "" : " (disabled)"));
   }

   public void reloadConfig() {
      this.enabled = this.plugin.getConfig().getBoolean("exploit-detection.enabled", true);
      this.consoleLogging = this.plugin.getConfig().getBoolean("exploit-detection.console-logging", true);
      this.fileLogging = this.plugin.getConfig().getBoolean("exploit-detection.file-logging", true);
      this.adminNotify = this.plugin.getConfig().getBoolean("exploit-detection.admin-notify", true);
      this.adminPermission = this.plugin.getConfig().getString("exploit-detection.admin-permission", "ultracoinflip.admin");
   }

   private void startWriterThread() {
      this.writerThread = new Thread(() -> {
         while (this.running || !this.logQueue.isEmpty()) {
            try {
               String message = this.logQueue.poll(TimeUnit.SECONDS.toMillis(1L), TimeUnit.MILLISECONDS);
               if (message != null && this.fileLogging) {
                  this.writeToFile(message);
               }
            } catch (InterruptedException var2) {
               Thread.currentThread().interrupt();
               break;
            }
         }

         String message;
         if (this.fileLogging) {
            while ((message = this.logQueue.poll()) != null) {
               this.writeToFile(message);
            }
         }
      }, "UltraCoinFlip-ExploitDetector");
      this.writerThread.setDaemon(true);
      this.writerThread.start();
   }

   private void writeToFile(String message) {
      try {
         PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(this.logFile, true)));

         try {
            writer.println(message);
         } catch (Throwable var6) {
            try {
               writer.close();
            } catch (Throwable var5) {
               var6.addSuppressed(var5);
            }

            throw var6;
         }

         writer.close();
      } catch (IOException var7) {
         this.plugin.getLogger().log(Level.WARNING, "Failed to write to exploit detection log", (Throwable)var7);
      }
   }

   public void report(Player player, ExploitDetector.ExploitType type, String details) {
      if (this.enabled && player != null) {
         UUID playerUuid = player.getUniqueId();
         String playerName = player.getName();
         ExploitDetector.PlayerExploitData data = this.playerExploitData.computeIfAbsent(playerUuid, k -> new ExploitDetector.PlayerExploitData());
         data.recordAttempt(type);
         String rateKey = playerUuid.toString() + "_" + type.name();
         long now = System.currentTimeMillis();
         Long lastTime = this.lastLogTime.get(rateKey);
         boolean shouldLog = lastTime == null || now - lastTime > 5000L;
         if (shouldLog) {
            this.lastLogTime.put(rateKey, now);
            String timestamp = this.dateFormat.format(new Date());
            int attemptCount = data.getCount(type);
            boolean isSuspicious = data.isSuspicious(type);
            String logMessage = String.format(
               "[%s] [EXPLOIT-%s] %s | Player=%s | UUID=%s | Attempts=%d | Suspicious=%s | Details=%s",
               timestamp,
               type.getSeverity(),
               type.name(),
               playerName,
               playerUuid,
               attemptCount,
               isSuspicious ? "YES" : "no",
               details
            );
            if (this.fileLogging) {
               this.logQueue.offer(logMessage);
            }

            if (this.consoleLogging) {
               if (isSuspicious) {
                  String consoleMsg = String.format(
                     "[SECURITY WARNING] Suspicious activity: %s by %s (%d attempts) - %s", type.getDescription(), playerName, attemptCount, details
                  );
                  this.plugin.getLogger().warning(consoleMsg);
               } else if ("HIGH".equals(type.getSeverity())) {
                  String consoleMsg = String.format("[SECURITY] %s: %s - %s", type.getDescription(), playerName, details);
                  this.plugin.getLogger().warning(consoleMsg);
               } else {
                  String consoleMsg = String.format("[SECURITY] %s: %s", type.getDescription(), playerName);
                  this.plugin.getLogger().info(consoleMsg);
               }
            }

            if (this.adminNotify && (isSuspicious || "HIGH".equals(type.getSeverity()))) {
               this.notifyAdmins(player, type, details, attemptCount, isSuspicious);
            }
         }
      }
   }

   public void reportCurrency(
      Player player,
      ExploitDetector.ExploitType type,
      CoinFlipGame.CurrencyType currencyType,
      String currencyId,
      double expectedAmount,
      double actualAmount,
      String details
   ) {
      if (this.enabled && player != null) {
         String fullDetails = String.format(
            "%s | Currency=%s/%s | Expected=%.2f | Actual=%.2f",
            details,
            currencyType.name(),
            currencyId != null ? currencyId : "default",
            expectedAmount,
            actualAmount
         );
         this.report(player, type, fullDetails);
      }
   }

   private void notifyAdmins(Player suspect, ExploitDetector.ExploitType type, String details, int attemptCount, boolean isSuspicious) {
      String prefix = this.plugin.getMessage("prefix");
      String alertMsg;
      if (isSuspicious) {
         alertMsg = String.format(
            "%s &c&l[SECURITY ALERT] &eSuspicious activity detected!\n&7Player: &f%s\n&7Type: &c%s\n&7Attempts: &c%d &7(in last 30s)\n&7Details: &f%s",
            prefix,
            suspect.getName(),
            type.getDescription(),
            attemptCount,
            details
         );
      } else {
         alertMsg = String.format("%s &e[SECURITY] &7Potential exploit attempt by &f%s&7: %s", prefix, suspect.getName(), type.getDescription());
      }

      for (Player admin : Bukkit.getOnlinePlayers()) {
         if (admin.hasPermission(this.adminPermission)) {
            this.plugin.getAdventureHelper().sendMessage(admin, alertMsg);
         }
      }
   }

   public boolean isPlayerSuspicious(UUID playerUuid) {
      ExploitDetector.PlayerExploitData data = this.playerExploitData.get(playerUuid);
      if (data == null) {
         return false;
      } else {
         for (ExploitDetector.ExploitType type : ExploitDetector.ExploitType.values()) {
            if (data.isSuspicious(type)) {
               return true;
            }
         }

         return false;
      }
   }

   public int getPlayerExploitCount(UUID playerUuid) {
      ExploitDetector.PlayerExploitData data = this.playerExploitData.get(playerUuid);
      if (data == null) {
         return 0;
      } else {
         int total = 0;

         for (ExploitDetector.ExploitType type : ExploitDetector.ExploitType.values()) {
            total += data.getCount(type);
         }

         return total;
      }
   }

   public void clearPlayerData(UUID playerUuid) {
      this.playerExploitData.remove(playerUuid);
      this.lastLogTime.keySet().removeIf(key -> key.startsWith(playerUuid.toString()));
   }

   public boolean isEnabled() {
      return this.enabled;
   }

   public void shutdown() {
      this.running = false;
      if (this.writerThread != null) {
         this.writerThread.interrupt();

         try {
            this.writerThread.join(5000L);
         } catch (InterruptedException var2) {
            Thread.currentThread().interrupt();
         }
      }

      String message;
      if (this.fileLogging) {
         while ((message = this.logQueue.poll()) != null) {
            this.writeToFile(message);
         }
      }

      this.plugin.getLogger().info("[ExploitDetector] Security system shutdown complete");
   }

   public static enum ExploitType {
      WITHDRAW_VERIFICATION_FAILED("Withdraw verification failed - balance didn't decrease", "HIGH"),
      DEPOSIT_VERIFICATION_FAILED("Deposit verification failed - balance didn't increase", "MEDIUM"),
      DOUBLE_CLICK_JOIN("Double-click join attempt blocked", "LOW"),
      RACE_CONDITION_JOIN("Race condition join attempt blocked", "MEDIUM"),
      GAME_ALREADY_TAKEN("Game already taken by another player", "LOW"),
      RAPID_JOIN_ATTEMPTS("Rapid join attempts detected", "MEDIUM"),
      JOIN_ROLLBACK("Join rollback - withdraw failed after taking game", "MEDIUM"),
      CURRENCY_MISMATCH("Currency amount mismatch detected", "HIGH");

      private final String description;
      private final String severity;

      private ExploitType(String description, String severity) {
         this.description = description;
         this.severity = severity;
      }

      public String getDescription() {
         return this.description;
      }

      public String getSeverity() {
         return this.severity;
      }
   }

   private static class PlayerExploitData {
      private final Map<ExploitDetector.ExploitType, AtomicInteger> counts = new ConcurrentHashMap<>();
      private final Map<ExploitDetector.ExploitType, Long> firstAttemptTime = new ConcurrentHashMap<>();

      private PlayerExploitData() {
      }

      public void recordAttempt(ExploitDetector.ExploitType type) {
         long now = System.currentTimeMillis();
         Long firstTime = this.firstAttemptTime.get(type);
         if (firstTime != null && now - firstTime <= 30000L) {
            this.counts.computeIfAbsent(type, k -> new AtomicInteger(0)).incrementAndGet();
         } else {
            this.counts.put(type, new AtomicInteger(1));
            this.firstAttemptTime.put(type, now);
         }
      }

      public int getCount(ExploitDetector.ExploitType type) {
         AtomicInteger count = this.counts.get(type);
         return count != null ? count.get() : 0;
      }

      public boolean isSuspicious(ExploitDetector.ExploitType type) {
         return this.getCount(type) >= 3;
      }
   }
}
